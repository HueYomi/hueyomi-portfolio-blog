{
  "id": "2",
  "title": "Building Scalable React Applications with TypeScript",
  "content": "# Building Scalable React Applications with TypeScript\n\nTypeScript has become an essential tool for building large-scale React applications. In this comprehensive guide, we'll explore how to leverage TypeScript to create maintainable, scalable, and robust React applications.\n\n## Why TypeScript for React?\n\nTypeScript brings several advantages to React development:\n\n- **Type Safety**: Catch errors at compile time\n- **Better IDE Support**: Enhanced autocomplete and refactoring\n- **Self-Documenting Code**: Types serve as documentation\n- **Easier Refactoring**: Confident code changes\n- **Team Collaboration**: Clear interfaces and contracts\n\n## Setting Up TypeScript with React\n\n### New Project\n```bash\nnpx create-react-app my-app --template typescript\n# or with Next.js\nnpx create-next-app@latest my-app --typescript\n```\n\n### Existing Project\n```bash\nnpm install --save-dev typescript @types/react @types/react-dom\n```\n\n## Essential TypeScript Patterns for React\n\n### 1. Component Props Typing\n\n```typescript\ninterface ButtonProps {\n  children: React.ReactNode;\n  onClick: () => void;\n  variant?: 'primary' | 'secondary';\n  disabled?: boolean;\n}\n\nconst Button: React.FC<ButtonProps> = ({ \n  children, \n  onClick, \n  variant = 'primary',\n  disabled = false \n}) => {\n  return (\n    <button \n      onClick={onClick} \n      disabled={disabled}\n      className={`btn btn-${variant}`}\n    >\n      {children}\n    </button>\n  );\n};\n```\n\n### 2. State Management with TypeScript\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface UserState {\n  users: User[];\n  loading: boolean;\n  error: string | null;\n}\n\nconst UserList: React.FC = () => {\n  const [state, setState] = useState<UserState>({\n    users: [],\n    loading: false,\n    error: null\n  });\n\n  const fetchUsers = async (): Promise<void> => {\n    setState(prev => ({ ...prev, loading: true }));\n    try {\n      const response = await fetch('/api/users');\n      const users: User[] = await response.json();\n      setState({ users, loading: false, error: null });\n    } catch (error) {\n      setState(prev => ({ \n        ...prev, \n        loading: false, \n        error: 'Failed to fetch users' \n      }));\n    }\n  };\n\n  return (\n    <div>\n      {state.loading && <div>Loading...</div>}\n      {state.error && <div>Error: {state.error}</div>}\n      {state.users.map(user => (\n        <div key={user.id}>{user.name}</div>\n      ))}\n    </div>\n  );\n};\n```\n\n### 3. Custom Hooks with TypeScript\n\n```typescript\ninterface UseApiResult<T> {\n  data: T | null;\n  loading: boolean;\n  error: string | null;\n  refetch: () => Promise<void>;\n}\n\nfunction useApi<T>(url: string): UseApiResult<T> {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchData = useCallback(async (): Promise<void> => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const result: T = await response.json();\n      setData(result);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'An error occurred');\n    } finally {\n      setLoading(false);\n    }\n  }, [url]);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  return { data, loading, error, refetch: fetchData };\n}\n\n// Usage\nconst UserProfile: React.FC<{ userId: number }> = ({ userId }) => {\n  const { data: user, loading, error } = useApi<User>(`/api/users/${userId}`);\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!user) return <div>User not found</div>;\n\n  return <div>{user.name}</div>;\n};\n```\n\n## Advanced TypeScript Patterns\n\n### 1. Generic Components\n\n```typescript\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T) => React.ReactNode;\n  keyExtractor: (item: T) => string | number;\n}\n\nfunction List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={keyExtractor(item)}>\n          {renderItem(item)}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Usage\nconst users: User[] = [/* ... */];\n\n<List\n  items={users}\n  keyExtractor={user => user.id}\n  renderItem={user => <span>{user.name}</span>}\n/>\n```\n\n### 2. Discriminated Unions for State\n\n```typescript\ntype AsyncState<T> = \n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: string };\n\nconst DataComponent: React.FC = () => {\n  const [state, setState] = useState<AsyncState<User[]>>({ status: 'idle' });\n\n  const handleFetch = async () => {\n    setState({ status: 'loading' });\n    try {\n      const data = await fetchUsers();\n      setState({ status: 'success', data });\n    } catch (error) {\n      setState({ \n        status: 'error', \n        error: error instanceof Error ? error.message : 'Unknown error' \n      });\n    }\n  };\n\n  switch (state.status) {\n    case 'idle':\n      return <button onClick={handleFetch}>Load Users</button>;\n    case 'loading':\n      return <div>Loading...</div>;\n    case 'success':\n      return <div>{state.data.length} users loaded</div>;\n    case 'error':\n      return <div>Error: {state.error}</div>;\n  }\n};\n```\n\n## Best Practices\n\n### 1. Strict TypeScript Configuration\n\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"noImplicitReturns\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true\n  }\n}\n```\n\n### 2. Use Interfaces for Props\n\n```typescript\n// Good\ninterface UserCardProps {\n  user: User;\n  onEdit: (user: User) => void;\n}\n\n// Avoid inline types for complex props\nconst UserCard: React.FC<{\n  user: { id: number; name: string; email: string };\n  onEdit: (user: { id: number; name: string; email: string }) => void;\n}> = ({ user, onEdit }) => {\n  // ...\n};\n```\n\n### 3. Leverage Type Guards\n\n```typescript\nfunction isUser(obj: any): obj is User {\n  return obj && typeof obj.id === 'number' && typeof obj.name === 'string';\n}\n\nconst processApiResponse = (data: unknown) => {\n  if (Array.isArray(data) && data.every(isUser)) {\n    // TypeScript knows data is User[] here\n    return data.map(user => user.name);\n  }\n  throw new Error('Invalid user data');\n};\n```\n\n## Testing with TypeScript\n\n```typescript\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button Component', () => {\n  it('calls onClick when clicked', () => {\n    const mockOnClick = jest.fn();\n    render(\n      <Button onClick={mockOnClick}>\n        Click me\n      </Button>\n    );\n    \n    fireEvent.click(screen.getByText('Click me'));\n    expect(mockOnClick).toHaveBeenCalledTimes(1);\n  });\n});\n```\n\n## Conclusion\n\nTypeScript transforms React development by providing type safety, better tooling, and improved maintainability. By following these patterns and best practices, you can build scalable React applications that are easier to maintain and debug.\n\nThe investment in learning TypeScript pays dividends in reduced bugs, improved developer experience, and better team collaboration. Start small, gradually adopt more advanced patterns, and enjoy the benefits of type-safe React development.\n\n## Resources\n\n- [TypeScript Handbook](https://www.typescriptlang.org/docs/)\n- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/)\n- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)",
  "summary": "Learn how to build maintainable and scalable React applications using TypeScript, including best practices for type safety and code organization.",
  "author": "Hue Nguyen Thi",
  "created_at": "2024-01-10T14:30:00Z",
  "updated_at": "2024-01-10T14:30:00Z",
  "tags": ["react", "typescript", "frontend", "scalability"],
  "published": true,
  "featured_image": "/assets/images/blog/react-typescript.jpg",
  "read_time": "12 min read",
  "category": "Development",
  "seo": {
    "meta_title": "Building Scalable React Apps with TypeScript - Complete Guide",
    "meta_description": "Master TypeScript in React development. Learn patterns, best practices, and techniques for building maintainable, scalable applications.",
    "og_image": "/assets/images/blog/react-typescript-og.jpg"
  }
} 